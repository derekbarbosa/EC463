#include <msp430.h> 


/**
 * main.c
 */

int buttonS1Pressed;
int buttonS2Pressed;
int rtcWakeup;

void signal_SOS(void){
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);

    P1OUT ^= BIT1;
    __delay_cycles(32000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(32000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(32000000);
    P1OUT ^= BIT1;

    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
    P1OUT ^= BIT1;
    __delay_cycles(16000000);
}

void main(void)
{
    WDTCTL = WDTPW | WDTHOLD;

//    HAL_System_Init();
//    HAL_IO_InitButtons();

//    GUI_Init();
//    GUI_InitRxCmd( &GUI_RXCommands[0],CALLBACKS_SIZE );

//    initRtc();
//    initAdc();

    signal_SOS();

    P2IFG &= ~(BIT3 | BIT7);

    unsigned int select = 0;
    buttonS1Pressed = 0;
    buttonS2Pressed = 0;
    rtcWakeup = 0;

    __enable_interrupt();


    while(1){

        __delay_cycles(220000);
        P1OUT ^= BIT1;
        select++;
    }
}
/*
void initRtc(void)
{
    //Initialize RTC, interrupts roughly every 5 seconds
    RTCMOD = 50;
    RTCCTL = RTCSS__VLOCLK | RTCSR |RTCPS__1024;
    RTCCTL |= RTCIE;
}

void initAdc(void)
{
    //Initialize the ADC Module
    /*
     * Base Address for the ADC Module
     * Use internal ADC bit as sample/hold signal to start conversion
     * USE MODOSC 5MHZ Digital Oscillator as clock source
     * Use default clock divider of 1
     */
    /*ADC_init(ADC_BASE,
             ADC_SAMPLEHOLDSOURCE_SC,
             ADC_CLOCKSOURCE_ADCOSC,
             ADC_CLOCKDIVIDER_1);

    ADC_enable(ADC_BASE);

    /*
     * Base Address for the ADC Module
     * Sample/hold for 256 clock cycles
     * Do not enable Multiple Sampling
     */
    /*ADC_setupSamplingTimer(ADC_BASE,
                           ADC_CYCLEHOLD_1024_CYCLES,
                           ADC_MULTIPLESAMPLESDISABLE);

    //Configure the Memory Buffer
    /*
     * Base Address for the ADC Module
     * Use input A12
     * Use positive reference of AVcc
     * Use negative reference of AVss
     */
   /* ADC_configureMemory(ADC_BASE,
                        ADC_INPUT_TEMPSENSOR,
                        ADC_VREFPOS_INT,
                        ADC_VREFNEG_AVSS);

    ADC_clearInterrupt(ADC_BASE,
                       ADC_COMPLETED_INTERRUPT);

    //Enable the Memory Buffer Interrupt
    ADC_enableInterrupt(ADC_BASE,
                        ADC_COMPLETED_INTERRUPT);

    //Configure internal reference
    //If ref voltage no ready, WAIT
    while(PMM_REFGEN_NOTREADY ==
          PMM_getVariableReferenceVoltageStatus());

    PMM_enableTempSensor();

    //Internal Reference ON
    PMM_enableInternalReference();

//    __delay_cycles(500);
}*/
